package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	goparser "go/parser"
	gotoken "go/token"
	_ "io/ioutil"
	"os"
	"path"
	"reflect"
	"strings"
	"unicode"
)

var (
	interfaceF = flag.String("interface", "", "interface type to define the rpc methods on")
	typeF      = flag.String("type", "", "comma separated list of types that should implement the interface")
	pkgF       = flag.String("pkg", "", "package containing functions providing the core functionality for the rpc")
	outF       = flag.String("out", "", "output package for client methods")
	outPkgF    = flag.String("out-pkg", "", "name of the package for which code is to be generated")
	excludeF   = flag.String("exclude", "", "comma separated list of files to exclude public functions from (relative to pkg)")
	templatesF = flag.String("templates", ".", "file/s in which the template functions are located")
)

func main() {

	flag.Parse()

	iface := *interfaceF
	types := strings.Split(*typeF, ",")
	dir := *pkgF
	outFile := *outF
	excludes := strings.Split(*excludeF, ",")
	outPkg := *outPkgF
	//	templateFiles := strings.Split(*templatesF, ",")

	_ = outFile

	fset := gotoken.NewFileSet() // positions are relative to fset

	// get the core functions to be exposed and their response names
	pkgs, err := goparser.ParseDir(fset, dir, returnFilter(excludes), 0)
	if err != nil {
		panic(err)
	}
	coreFuncs := getFuncs(pkgs)

	// get the interface to be populated (present in current dir)
	pkgs, err = goparser.ParseDir(fset, ".", nil, goparser.ParseComments)
	if err != nil {
		panic(err)
	}
	interfaceDef := fmt.Sprintf(`
type %s interface{

}`, iface)

	// populate interface and stringify func defs
	stringFuncs, interfaceDef := populateInterface(interfaceDef, coreFuncs, dir)

	buf := new(bytes.Buffer)
	fmt.Fprintln(buf, "// File generated by github.com/ebuchman/rpc-gen")
	fmt.Fprintln(buf, "package", outPkg)
	fmt.Fprintln(buf, "")
	fmt.Fprintf(buf, interfaceDef)

	// get the template functions for implementing the rpc calls
	templates := getTemplates(pkgs)
	if len(templates) != len(types) {
		panic(fmt.Sprintf("rpc-gen requires equal numbers of types and templates. Got %d, %d", len(types), len(templates)))
	}

	// TODO: parse comments to register functions

	// for each client type, implement the interface
	// using its template and the stringFuncs
	for _, clientType := range types {
		implementation, err := implementInterface(clientType, stringFuncs, templates[clientType])
		if err != nil {
			panic(err)
		}
		// write implementation to buffer
		buf.Write(implementation)
	}

	//fmt.Println(string(buf.Bytes()))
	// save buffer to file
	/*newFile := "client_methods.go"
	data := buf.Bytes()
	if err := ioutil.WriteFile(newFile, data, 0660); err != nil {
		panic(err)
	}*/
}

func joinArgTypes(names, types []string) string {
	union := make([]string, len(names))
	for i, n := range names {
		union[i] = fmt.Sprintf("%s %s", n, types[i])
	}
	return strings.Join(union, ",")
}

func CamelToLower(s string) string {
	lower := ""
	for i := 0; i < len(s); i++ {
		if unicode.IsUpper(rune(s[i])) && i != 0 {
			lower += "_"
		}
		lower += string(unicode.ToLower(rune(s[i])))
	}
	return lower
}

func compileJob(buf *bytes.Buffer, f Func, job Job) {
	switch job.ident {
	case "name":
		fmt.Fprintf(buf, f.Name)
	case "args":
		fmt.Fprintf(buf, joinArgTypes(f.ArgNames, f.ArgTypes))
	case "response":
		fmt.Fprintf(buf, strings.Join(f.ReturnTypes, ","))
	case "lowername":
		fmt.Fprintf(buf, CamelToLower(f.Name))
	default:
		// check if the ident is registered
		// and if so do something crazy here
	}
}

func (p *parser) makeMethod(buf *bytes.Buffer, f Func) {
	for i, t := range p.txt {
		// write the preceding text
		fmt.Fprintf(buf, t)

		// compile a job to txt
		if i < len(p.jobs) {
			compileJob(buf, f, p.jobs[i])
		}
	}
	fmt.Fprintf(buf, "\n\n")
}

// parse the template. for each function, implement
func implementInterface(clientType string, stringFuncs []Func, tmpl string) ([]byte, error) {
	p := Parser(tmpl)
	if err := p.run(); err != nil {
		return nil, err
	}
	buf := new(bytes.Buffer)
	for _, f := range stringFuncs {
		p.makeMethod(buf, f)
		fmt.Println(string(buf.Bytes()))
	}
	return buf.Bytes(), nil
}

func typeToString(typ ast.Expr) string {
	switch t := typ.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return typeToString(t.X) + "." + t.Sel.String()
	case *ast.StarExpr:
		return "*" + typeToString(t.X)
	case *ast.ArrayType:
		return "[]" + typeToString(t.Elt)
	}
	panic(fmt.Sprintf("unknown type %v", reflect.TypeOf(typ)))
}

type Func struct {
	Name        string
	ArgNames    []string
	ArgTypes    []string
	ReturnTypes []string
}

func NewFunc(name string, nargs int) Func {
	return Func{
		Name:        name,
		ArgNames:    make([]string, nargs),
		ArgTypes:    make([]string, nargs),
		ReturnTypes: []string{"*Response" + name},
	}
}

// create an interface definition containing all defined methods
func populateInterface(baseDef string, funcs map[string]*ast.Object, pkg string) ([]Func, string) {
	stringFuncs := make([]Func, len(funcs))

	// pull off the final }
	baseDef = baseDef[:len(baseDef)-1]
	// extract each functions string info,
	// add to stringFuncs and append to interface def
	i := 0 // using append on stringFuncs was breaking ...
	for name, obj := range funcs {
		baseDef += "\t" + name + "("
		fdecl := obj.Decl.(*ast.FuncDecl)
		ftype := fdecl.Type
		argList := ftype.Params.List
		thisFunc := NewFunc(name, len(argList))
		for i, p := range argList {
			t := typeToString(p.Type)
			n := p.Names[0].Name
			thisFunc.ArgNames[i] = n
			thisFunc.ArgTypes[i] = t
			baseDef += n + " " + t + ", "
		}
		stringFuncs[i] = thisFunc
		if len(argList) > 0 {
			baseDef = baseDef[:len(baseDef)-2]
		}
		baseDef += ")"
		baseDef += fmt.Sprintf(" (*%s.Response%s, error)\n", pkg, name)
		i += 1
	}
	return stringFuncs, baseDef + "\n}\n"
}

func getTemplates(pkgs map[string]*ast.Package) map[string]string {
	templates := make(map[string]string)
	comments := getComments(pkgs)
	for _, c := range comments {
		txt := c.Text[2:]
		if strings.HasPrefix(txt, "rpc-gen:template:") {
			txt = txt[len("rpc-gen:template:"):]
			// next token up to a space should be the client type
			name := ""
			i := 0
			for ; txt[i:i+1] != " "; i++ {
				name += txt[i : i+1]
			}
			txt = txt[i : len(txt)-2]
			templates[name] = txt
		}
	}
	return templates
}

// return a list of all comments
func getComments(pkgs map[string]*ast.Package) []*ast.Comment {
	// is this a comment or what
	comments := []*ast.Comment{}
	for _, pkg := range pkgs {
		fs := pkg.Files
		for _, f := range fs {
			for _, c := range f.Comments {
				for _, cc := range c.List {
					comments = append(comments, cc)
				}
			}
		}
	}
	return comments
}

// returns a list of all exported functions in a pkg
func getFuncs(pkgs map[string]*ast.Package) map[string]*ast.Object {
	objs := make(map[string]*ast.Object)
	for _, pkg := range pkgs {
		fs := pkg.Files
		for _, f := range fs {
			// Print the scope
			for n, o := range f.Scope.Objects {
				if o.Kind == ast.Fun && ast.IsExported(n) {
					objs[n] = o
				}
			}

		}
	}
	return objs
}

func returnFilter(excludes []string) func(os.FileInfo) bool {
	return func(info os.FileInfo) bool {
		name := info.Name()
		var excluded bool
		for _, ex := range excludes {
			if name == ex {
				excluded = true
				break
			}
		}
		return !info.IsDir() && !excluded && path.Ext(name) == ".go" && !strings.HasSuffix(name, "_test.go")
	}

}

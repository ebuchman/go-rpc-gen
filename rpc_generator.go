package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	goparser "go/parser"
	gotoken "go/token"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"unicode"
)

var (
	GoPath = os.Getenv("GOPATH")

	interfaceF = flag.String("interface", "", "interface type to define the rpc methods on")
	typeF      = flag.String("type", "", "comma separated list of types that should implement the interface")
	pkgF       = flag.String("pkg", "", "package containing functions providing the core functionality for the rpc")
	outF       = flag.String("out", "", "output package for client methods")
	outPkgF    = flag.String("out-pkg", "", "name of the package for which code is to be generated")
	excludeF   = flag.String("exclude", "", "comma separated list of files to exclude public functions from (relative to pkg)")
	templatesF = flag.String("templates", ".", "file/s in which the template functions are located")
)

/*
	RpcGen language spec:
	There are `definitions` and `templates`.
	Templates use definitions.
	A definition is either an `interface`, a `function`, or a `set`.
	A `set` is a map from types (eg. "string", "[]byte") to functions that serialize that type
*/

type DefInterface struct {
	name string
	code string
}

type DefFunction struct {
	name string
	code string
}

type DefSet struct {
	code string
}

func onePkg(pkgs map[string]*ast.Package) *ast.Package {
	if len(pkgs) > 1 {
		panic("More than one package found. Exiting")
	}
	pkg := new(ast.Package)
	var pkgname string
	for n, p := range pkgs {
		pkg = p
		pkgname = n
	}
	fmt.Println("pkgname:", pkgname)
	_ = pkgname
	return pkg
}

func goImportPathFromDir(dir string) (string, error) {
	dir, _ = filepath.Abs(dir)
	prefix := path.Join(GoPath, "src")
	if strings.HasPrefix(dir, prefix) {
		return dir[len(prefix)+1:], nil
	} else {
		return "", fmt.Errorf("%s not on the $GOPATH", dir)
	}
}

func main() {

	flag.Parse()

	iface := *interfaceF
	types := strings.Split(*typeF, ",")
	dir := *pkgF
	outFile := *outF
	excludes := strings.Split(*excludeF, ",")
	outPkg := *outPkgF
	//	templateFiles := strings.Split(*templatesF, ",")

	_ = outFile

	fset := gotoken.NewFileSet() // positions are relative to fset

	// get the core functions to be exposed
	corePkgs, err := goparser.ParseDir(fset, dir, returnFilter(excludes), 0)
	if err != nil {
		panic(err)
	}
	fmt.Println(corePkgs)
	corePkg := onePkg(corePkgs)
	coreFuncs := getFuncs(corePkg)
	corePkgImportPath, err := goImportPathFromDir(dir)
	if err != nil {
		panic(err)
	}

	// get the interface to be populated (present in current dir)
	pkgs, err := goparser.ParseDir(fset, ".", nil, goparser.ParseComments)
	if err != nil {
		panic(err)
	}
	pkg := onePkg(pkgs)

	interfaceDef := fmt.Sprintf(`
type %s interface{

}`, iface)

	// init the rpc generator by parsing the templates and definitions
	rpcGen, err := initRpcGen(pkg)
	if err != nil {
		panic(err)
	}
	if len(rpcGen.templates) != len(types) {
		panic(fmt.Sprintf("rpc-gen requires equal numbers of types and templates. Got %d, %d", len(types), len(rpcGen.templates)))
	}

	imports := getImports(corePkg, corePkgImportPath)
	// populate interface and stringify func defs
	stringFuncs, interfaceDef, neededImports := populateInterface(interfaceDef, coreFuncs, imports, dir, corePkgImportPath)

	// add base imports to neededImports
	for k, v := range rpcGen.imports {
		neededImports[k] = v
	}
	buf := new(bytes.Buffer)
	fmt.Fprintln(buf, "// File generated by github.com/ebuchman/rpc-gen")
	fmt.Fprintln(buf, "")
	fmt.Fprintln(buf, "package", outPkg)
	fmt.Fprintln(buf, "")
	fmt.Fprintln(buf, "import(")
	for n, im := range neededImports {
		fmt.Println(n, im)
		if n != path.Base(im) {
			fmt.Fprintln(buf, "\t"+n+" \""+im+"\"")
		} else {
			fmt.Fprintln(buf, "\t\""+im+"\"")

		}
	}
	fmt.Fprintln(buf, ")")
	fmt.Fprintln(buf, "")
	fmt.Fprintf(buf, interfaceDef)

	fmt.Println(string(buf.Bytes()))

	// for each client type, implement the interface
	// using its template and the stringFuncs
	for _, clientType := range types {
		implementation, err := rpcGen.implementInterface(clientType, stringFuncs)
		if err != nil {
			panic(err)
		}
		// write implementation to buffer
		buf.Write(implementation)
	}

	//fmt.Println(string(buf.Bytes()))
	// save buffer to file
	newFile := "client_methods.go"
	data := buf.Bytes()
	if err := ioutil.WriteFile(newFile, data, 0660); err != nil {
		panic(err)
	}
}

func joinArgTypes(names, types []string) string {
	union := make([]string, len(names))
	for i, n := range names {
		union[i] = fmt.Sprintf("%s %s", n, types[i])
	}
	return strings.Join(union, ", ")
}

func CamelToLower(s string) string {
	lower := ""
	for i := 0; i < len(s); i++ {
		if unicode.IsUpper(rune(s[i])) && i != 0 {
			lower += "_"
		}
		lower += string(unicode.ToLower(rune(s[i])))
	}
	return lower
}

func defToCall(def string, args []string) string {
	return ""
}

func (rg *RpcGen) compileJob(buf *bytes.Buffer, f Func, job Job) error {
	argNames := f.ArgNames
	argTypes := f.ArgTypes
	retTypes := f.ReturnTypes
	// ident is either a keyword or a variable name
	spl := strings.Split(job.ident, ".")
	ident := spl[0]
	switch ident {
	case "name":
		fmt.Fprintf(buf, f.Name)
	case "args":
		field := spl[1]
		if i, err := strconv.Atoi(field); err == nil {
			argNames = []string{f.ArgNames[i]}
			argTypes = []string{f.ArgTypes[i]}
		}
		switch spl[1] {
		case "def":
			fmt.Fprintf(buf, joinArgTypes(argNames, argTypes))
		case "ident":
			if len(f.ArgNames) == 0 {
				fmt.Fprintf(buf, "nil")
			} else {
				fmt.Fprintf(buf, strings.Join(argNames, ", "))
			}
		case "name":
			if len(f.ArgNames) == 0 {
				fmt.Fprintf(buf, "nil")
			} else {
				fmt.Fprintf(buf, "[]string{\""+strings.Join(argNames, "\" , \"")+"\"}")
			}
		}
	case "response":
		if len(spl) > 1 {
			field := spl[1]
			if i, err := strconv.Atoi(field); err == nil {
				retTypes = []string{f.ReturnTypes[i]}
			}
		}
		fmt.Fprintf(buf, strings.Join(retTypes, ", "))
	case "lowername":
		fmt.Fprintf(buf, "\""+CamelToLower(f.Name)+"\"")
	default:
		// check if the ident is registered
		// and if so call the function
		if def, ok := rg.funcdefs[job.ident]; ok {
			fmt.Fprintf(buf, defToCall(def, argNames))
		} else {
			return fmt.Errorf("Unknown identifier %s", job.ident)
		}
	}
	return nil
}

func (rg *RpcGen) makeMethod(buf *bytes.Buffer, f Func) error {
	for i, t := range rg.txt {
		// write the preceding text
		fmt.Fprintf(buf, t)

		// compile a job to txt
		if i < len(rg.jobs) {
			if err := rg.compileJob(buf, f, rg.jobs[i]); err != nil {
				return err
			}
		}
	}
	fmt.Fprintf(buf, "\n\n")
	return nil
}

func (rg *RpcGen) SetContext(txt []string, jobs []Job) {
	rg.txt = txt
	rg.jobs = jobs
}

// parse the template. for each function, implement
func (rg *RpcGen) implementInterface(clientType string, stringFuncs []*Func) ([]byte, error) {
	tmp := rg.templates[clientType]
	p := Parser(tmp)
	if err := p.run(); err != nil {
		return nil, err
	}
	txt, jobs := p.results()
	//fmt.Println(jobs)
	rg.SetContext(txt, jobs)
	buf := new(bytes.Buffer)
	for _, f := range stringFuncs {
		rg.makeMethod(buf, *f)
	}
	//fmt.Println(string(buf.Bytes()))
	return buf.Bytes(), nil
}

func typeToString(typ ast.Expr) string {
	switch t := typ.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return typeToString(t.X) + "." + t.Sel.String()
	case *ast.StarExpr:
		return "*" + typeToString(t.X)
	case *ast.ArrayType:
		return "[]" + typeToString(t.Elt)
	}
	panic(fmt.Sprintf("unknown type %v", reflect.TypeOf(typ)))
}

type Func struct {
	Name        string
	ArgNames    []string
	ArgTypes    []string
	ReturnTypes []string
}

func NewFunc(name string, nargs, nret int) Func {
	return Func{
		Name:        name,
		ArgNames:    make([]string, nargs),
		ArgTypes:    make([]string, nargs),
		ReturnTypes: make([]string, nret), //[]string{"*Response" + name},
	}
}

func objectToStringFunc(name string, obj *ast.Object) Func {
	fdecl := obj.Decl.(*ast.FuncDecl)
	ftype := fdecl.Type
	argList := ftype.Params.List
	retList := ftype.Results.List
	thisFunc := NewFunc(name, len(argList), len(retList))
	for i, p := range argList {
		t := typeToString(p.Type)
		n := p.Names[0].Name
		thisFunc.ArgNames[i] = n
		thisFunc.ArgTypes[i] = t
	}
	for i, r := range retList {
		thisFunc.ReturnTypes[i] = typeToString(r.Type)
	}
	return thisFunc
}

/*

	neededImps := make(map[string]string)
	for _, f := range stringFuncs {
	}
	fmt.Println("needed!", neededImps)
	return neededImps
*/

func updateFunctionAndImport(f *Func, allImps map[string]string, neededImps map[string]string, pkgName, pkgPath string) {
	fmt.Println(f)
	for i, arg := range f.ArgTypes {
		fmt.Println(i, arg)
		f.ArgTypes[i] = updateImport(f, arg, allImps, &neededImps, pkgName, pkgPath)
	}

	for i, ret := range f.ReturnTypes {
		fmt.Println(i, ret)
		f.ReturnTypes[i] = updateImport(f, ret, allImps, &neededImps, pkgName, pkgPath)
	}

}

// create an interface definition containing all defined methods
func populateInterface(baseDef string, funcs map[string]*ast.Object, imports map[string]string, pkgName, pkgPath string) ([]*Func, string, map[string]string) {
	stringFuncs := make([]*Func, len(funcs))

	neededImps := make(map[string]string)

	// pull off the final }
	baseDef = baseDef[:len(baseDef)-1]
	// extract each functions string info,
	// add to stringFuncs and append to interface def
	i := 0 // using append on stringFuncs was breaking ...
	for name, obj := range funcs {
		baseDef += "\t" + name + "("
		thisFunc := objectToStringFunc(name, obj)
		updateFunctionAndImport(&thisFunc, imports, neededImps, pkgName, pkgPath)
		for i, n := range thisFunc.ArgNames {
			t := thisFunc.ArgTypes[i]
			baseDef += n + " " + t + ", "
		}
		stringFuncs[i] = &thisFunc
		if len(thisFunc.ArgNames) > 0 { // argList (?)
			baseDef = baseDef[:len(baseDef)-2]
		}
		baseDef += ") ("
		baseDef += strings.Join(thisFunc.ReturnTypes, ", ")
		baseDef += ")\n"
		//baseDef += fmt.Sprintf(" (*%s.Response%s, error)\n", pkg, name)
		i += 1
	}
	return stringFuncs, baseDef + "\n}\n", neededImps
}

type RpcGen struct {
	templates map[string]string
	ifaceDef  string
	funcdefs  map[string]string

	imports map[string]string // default imports for template functions

	txt  []string
	jobs []Job
}

func initRpcGen(pkg *ast.Package) (*RpcGen, error) {
	rpcGen := &RpcGen{
		templates: make(map[string]string),
		funcdefs:  make(map[string]string),
		imports:   make(map[string]string),
	}

	comments := getComments(pkg)
	//funcs := getFuncs(pkgs)
	for _, c := range comments {
		txt := c.Text[2:]
		if !strings.HasPrefix(txt, "rpc-gen:") {
			continue
		}

		txt = txt[len("rpc-gen:"):]
		txtspl := strings.SplitN(txt, " ", 2)
		rest := ""
		if len(txtspl) == 2 {
			rest = txtspl[1]
		}
		def := txtspl[0]

		defs := strings.Split(def, ":")
		typ := defs[0]
		switch typ {
		case "template":
			txt = txt[len("template:"):]
			// next token up to a space should be the client type
			name := ""
			i := 0
			for ; txt[i:i+1] != " "; i++ {
				name += txt[i : i+1]
			}
			txt = txt[i : len(txt)-2]
			//fmt.Println("TEMPLATE:", name, txt)
			rpcGen.templates[name] = txt
		case "define-set":
			// TODO
		case "define-interface":
			// the interface is all in a comment
			spl := strings.SplitN(rest, "\n", 2)
			//name := spl[0]
			defn := spl[1]
			rpcGen.ifaceDef = defn // */ ?

		case "define-func":
			//name := defs[1]
			// the function definition follows the comment
			// in the code.
			//pos := c.End()

			//rpcGen.funcdefs[name] = defn
		case "imports":
			rest = txt[len("imports"):]
			fmt.Println("REST:", rest)
			spl := strings.Split(rest, "\n")
			fmt.Println("SPL:", spl)
			for _, s := range spl[1:] {
				if strings.HasPrefix(s, "*") {
					break
				}
				sp := strings.Split(s, " ")
				importName, importPath := "", ""
				if len(sp) > 1 {
					importName = sp[0]
					importPath = sp[1]
				} else {
					importPath = sp[0]
					importName = path.Base(importPath)
				}
				fmt.Println(importName, importPath)
				rpcGen.imports[importName] = importPath
			}
		default:
			// expects a name registered by "define-set"
			// ie. serialization routine for a particular type

		}
	}
	return rpcGen, nil
}

// return a list of all comments
func getComments(pkg *ast.Package) []*ast.Comment {
	// is this a comment or what
	comments := []*ast.Comment{}
	fs := pkg.Files
	for _, f := range fs {
		for _, c := range f.Comments {
			for _, cc := range c.List {
				comments = append(comments, cc)
			}
		}
	}
	return comments
}

// get list of all required imports for the args/returns of the
// given functions.
func getImports(pkg *ast.Package, pkgPath string) map[string]string {
	allImps := make(map[string]string)
	fs := pkg.Files
	for _, f := range fs {
		for _, imp := range f.Imports {
			impPath := imp.Path
			impPathVal := strings.Trim(impPath.Value, "\"")
			name := path.Base(impPathVal)
			impName := imp.Name
			if impName != nil {
				name = impName.Name
			}
			allImps[name] = impPathVal
			fmt.Println("set imp", name, impPathVal)
		}
	}
	return allImps
}

func isBuiltin(arg string) bool {
	arg, _ = stripPointerArray(arg)
	switch arg {
	case "bool",
		"byte",
		"complex128",
		"complex64",
		"error",
		"float32",
		"float64",
		"int",
		"int16",
		"int32",
		"int64",
		"int8",
		"rune",
		"string",
		"uint",
		"uint16",
		"uint32",
		"uint64",
		"uint8",
		"uintptr":
		return true
	default:
		return false
	}
}

func stripPointerArray(imp string) (string, string) {
	pre := ""
	for i := 0; i < len(imp); i++ {
		if strings.Contains("[]*", imp[i:i+1]) {
			pre += imp[i : i+1]
		}
	}
	return imp[len(pre):], pre
}

func updateImport(f *Func, arg string, allImps map[string]string, neededImps *map[string]string, pkgName, pkgPath string) string {
	// if there's a `.`, figure out the
	// needed import
	spl := strings.Split(arg, ".")
	fmt.Println("ARG:", arg, spl)
	if len(spl) > 1 {
		imp := spl[0] // may have *s and []s
		imp, _ = stripPointerArray(imp)
		(*neededImps)[imp] = allImps[imp]
		return arg
	} else {

		// determine if type not built in
		// (ie. was defined in this package)
		if !isBuiltin(arg) {
			(*neededImps)[pkgName] = pkgPath
			argNoStar, prefix := stripPointerArray(arg)
			newType := prefix + pkgName + "." + argNoStar
			return newType
		}
	}
	return arg
}

// returns a list of all exported functions in a pkg
func getFuncs(pkg *ast.Package) map[string]*ast.Object {
	objs := make(map[string]*ast.Object)
	fs := pkg.Files
	for _, f := range fs {
		// Print the scope
		for n, o := range f.Scope.Objects {
			if o.Kind == ast.Fun && ast.IsExported(n) {
				objs[n] = o
			}
		}

	}
	return objs
}

func returnFilter(excludes []string) func(os.FileInfo) bool {
	return func(info os.FileInfo) bool {
		name := info.Name()
		var excluded bool
		for _, ex := range excludes {
			if name == ex {
				excluded = true
				break
			}
		}
		return !info.IsDir() && !excluded && path.Ext(name) == ".go" && !strings.HasSuffix(name, "_test.go")
	}

}
